# Python Keywords:
## 1 and
1. Логическое И в условных выражениях.
2. Возврат первого ложного значения или последнего истинного.
3. Сокращённое вычисление (short-circuit evaluation).
4. Использование в булевых операциях.
---
## 2 or
1. Логическое ИЛИ в условных выражениях.
2. Возврат первого истинного значения.
3. Сокращённое вычисление (short-circuit evaluation).
4. Использование в булевых операциях.
---
## 3 not
1. Логическое отрицание.
2. Инверсия булевых значений.
3. Использование в условных выражениях для проверки на ложность.
---
## 4 if
1. Проверка условия в условных выражениях.
2. Запуск блока кода при выполнении условия.
3. Использование в тернарном операторе (сокращённая форма).
4. Вложенность для проверки множественных условий (в сочетании с `elif` и `else`).
---
## 5 elif
1. Проверка дополнительных условий после `if`.
2. Альтернатива вложенным `if` для улучшения читаемости.
3. Использование в цепочке условий для выбора одного из нескольких блоков кода.
---
## 6 else
1. Выполнение блока кода, если условие в `if` или `elif` не выполнено.
2. Использование в циклах (`for`, `while`) для выполнения блока кода после завершения цикла без прерывания (`break`).
3. Использование в конструкциях `try-except` для выполнения блока кода при отсутствии исключений.
---
## 7 True
1. Булевое значение истины.
2. Использование в условных выражениях и логических операциях.
3. Результат сравнений и логических операций.
4. Часть встроенных констант Python.
---
## 8 False
1. Булевое значение лжи.
2. Использование в условных выражениях и логических операциях.
3. Результат сравнений и логических операций.
4. Часть встроенных констант Python.
---
## 9 None 
1. Обозначение отсутствия значения или пустого объекта.
<!-- 2. Использование в качестве значения по умолчанию для аргументов функций. -->
<!-- 3. Результат функций, которые не возвращают явного значения. -->
4. Проверка на отсутствие значения в условных выражениях.
5. Часть встроенных констант Python.
---
## 10 in
1. Проверка вхождения элемента в коллекцию (список, кортеж, строка, множество, словарь).
2. Использование в условных выражениях.
<!-- 3. Проверка наличия ключа в словаре. -->
<!-- 4. Использование в генераторах и comprehensions. -->
5. Работа с итерируемыми объектами.
---
## 11 is
<!-- 1. Проверка идентичности объектов (сравнение по ссылке). -->
<!-- 2. Использование для сравнения с `None`, `True`, `False`. -->
<!-- 3. Определение, ссылаются ли две переменные на один и тот же объект в памяти. -->
4. Применение в условных выражениях.
<!-- 5. Отличие от `==`, который сравнивает значения, а не идентичность. -->
---
## 12 match
<!-- 1. Сопоставление с образцом (pattern matching). -->
<!-- 2. Проверка структуры данных. -->
3. Сравнение с конкретными значениями.
<!-- 4. Извлечение значений из сложных структур. -->
5. Обработка различных случаев (case) в зависимости от соответствия.
<!-- 6. Использование охранных выражений (guards) для дополнительных условий. -->
<!-- 7. Поддержка вложенных паттернов. -->
8. Обработка исключительных случаев с помощью wildcard (`_`).
---
## 13 case
1. Определение паттерна для сопоставления.
<!-- 2. Обработка конкретного значения или структуры данных. -->
<!-- 3. Извлечение и привязка значений из сопоставленных данных. -->
<!-- 4. Использование охранных выражений (guards) для дополнительных условий. -->
<!-- 5. Поддержка вложенных паттернов. -->
<!-- 6. Обработка нескольких случаев через логическое ИЛИ (`|`). -->
7. Использование wildcard (`_`) для обработки всех остальных случаев.
---
<!-- ## 14 _ -->
1. Использование как временной или неиспользуемой переменной.
<!-- 2. Обозначение игнорируемых значений при распаковке. -->
<!-- 3. Использование в интерактивных средах для хранения результата последнего выражения. -->
4. Применение в качестве wildcard (универсального шаблона) в `match`-выражениях.
<!-- 5. Использование в i18n (интернационализации) для обозначения переводимых строк (в некоторых библиотеках). -->
---
## 15 for
1. Итерация по элементам итерируемых объектов.
2. Использование в циклах для выполнения повторяющихся действий.
3. Работа с последовательностями (списки, кортежи, строки, множества, словари).
<!-- 4. Использование в генераторах и comprehensions. -->
<!-- 5. Вложенные циклы для обработки многомерных структур. -->
<!-- 6. Использование в сочетании с `else` для выполнения блока кода после завершения цикла. -->
---
## 16 while
1. Выполнение цикла до тех пор, пока условие истинно.
2. Использование для повторяющихся действий с проверкой условия перед каждой итерацией.
3. Возможность создания бесконечных циклов.
4. Управление потоком выполнения с помощью `break` и `continue`.
<!-- 5. Использование в сочетании с `else` для выполнения блока кода после завершения цикла. -->
---
## 17 break
1. Прерывание выполнения цикла (`for`, `while`).
2. Выход из цикла досрочно при выполнении определённого условия.
3. Использование только внутри циклов.
4. Прекращение текущей итерации и всех последующих.
---
## 18 continue
1. Пропуск оставшейся части текущей итерации цикла (`for`, `while`).
2. Переход к следующей итерации цикла.
3. Использование только внутри циклов.
4. Управление потоком выполнения без полного прерывания цикла.
---
## 19 pass
1. Заглушка для пустых блоков кода.
2. Использование в местах, где синтаксически требуется код, но логически он не нужен.
3. Применение в функциях, классах, циклах и условных выражениях.
4. Отсутствие выполнения каких-либо действий.
---
## 20 def
1. Определение пользовательских функций.
2. Создание именованных блоков кода для повторного использования.
3. Возможность задания параметров и аргументов.
4. Поддержка вложенных функций.
<!-- 5. Использование декораторов. -->
---
## 21 return
1. Возврат значения из функции.
2. Завершение выполнения функции.
<!-- 3. Возможность возврата нескольких значений (в виде кортежа). -->
<!-- 4. Возврат `None`, если значение не указано. -->
5. Использование только внутри функций.
---
## 22 lambda
1. Создание анонимных функций.
2. Использование для простых операций.
<!-- 3. Возможность передачи в качестве аргумента в функции высшего порядка. -->
<!-- 4. Ограниченность одним выражением. -->
<!-- 5. Отсутствие имени и многострочности. -->
---
## 23 import
1. Подключение внешних модулей и библиотек.
2. Импорт функций, классов и переменных из модулей.
3. Использование псевдонимов с помощью `as`.
4. Импорт отдельных объектов из модулей.
<!-- 5. Поддержка вложенных и динамических импортов. -->
---
## 24 from
1. Импорт конкретных объектов из модулей.
2. Использование в сочетании с `import`.
<!-- 3. Упрощение доступа к функциям, классам и переменным без указания имени модуля. -->
4. Поддержка импорта всех объектов через `*`.
<!-- 5. Применение в динамических импортах. -->
---
## 25 as
1. Создание псевдонимов для импортируемых модулей или объектов.
<!-- 2. Использование в конструкции `with` для присвоения результата контекстного менеджера. -->
<!-- 3. Применение в обработке исключений для присвоения исключения переменной. -->
<!-- 4. Упрощение работы с длинными или конфликтующими именами. -->
---
## 26 try
1. Начало блока для обработки исключений.
2. Использование в сочетании с `except`, `else` и `finally`.
<!-- 3. Обработка ошибок и исключений в безопасном режиме. -->
<!-- 4. Предотвращение аварийного завершения программы. -->
<!-- 5. Проверка кода на наличие исключений. -->
---
## 27 except
1. Обработка исключений в блоке `try`.
<!-- 2. Указание типа исключения для перехвата. -->
<!-- 3. Возможность перехвата нескольких типов исключений. -->
4. Использование для выполнения кода при возникновении ошибки.
<!-- 5. Присвоение исключения переменной с помощью `as`. -->
---
## 28 finally
1. Выполнение блока кода после завершения `try` и `except`, независимо от наличия исключения.
2. Использование для освобождения ресурсов или завершающих действий.
3. Гарантированное выполнение кода, даже если произошло исключение или был вызван `return`.
4. Работа в сочетании с `try` и `except`.
---
## 29 raise
<!-- 1. Вызов исключения вручную. -->
<!-- 2. Использование для генерации встроенных или пользовательских исключений. -->
<!-- 3. Повторное возбуждение перехваченного исключения. -->
<!-- 4. Указание сообщения об ошибке. -->
<!-- 5. Контроль потока выполнения программы через исключения. -->
---
## 30 class
1. Создание пользовательских классов.
2. Определение атрибутов и методов.
<!-- 3. Поддержка наследования. -->
<!-- 4. Создание экземпляров объектов. -->
<!-- 5. Использование магических методов для настройки поведения объектов. -->
<!-- 6. Поддержка декораторов классов. -->
<!-- 7. Организация кода через объектно-ориентированное программирование. -->
---
## 31 type
1. Получение типа объекта.
<!-- 2. Создание новых типов (классов) динамически. -->
<!-- 3. Проверка принадлежности объекта к определенному типу. -->
<!-- 4. Использование в аннотациях типов для указания ожидаемого типа. -->
<!-- 5. Работа с метаклассами для управления созданием классов. -->
---
## 32 global
1. Объявление глобальной переменной внутри функции.
<!-- 2. Изменение значения глобальной переменной внутри локальной области видимости. -->
<!-- 3. Указание на использование переменной, определённой на уровне модуля. -->
<!-- 4. Запрет на создание локальной переменной с тем же именем. -->
---
## 33 nonlocal
<!-- 1. Объявление переменной из внешней (неглобальной) области видимости. -->
<!-- 2. Изменение значения переменной из enclosing функции. -->
<!-- 3. Использование во вложенных функциях. -->
<!-- 4. Запрет на создание локальной переменной с тем же именем. -->
---
## 34 with
<!-- 1. Упрощение работы с контекстными менеджерами. -->
<!-- 2. Автоматическое управление ресурсами (открытие/закрытие, блокировка/разблокировка). -->
<!-- 3. Гарантированное выполнение завершающих действий через метод `__exit__`. -->
<!-- 4. Использование для работы с файлами, сетевыми соединениями и другими ресурсами. -->
<!-- 5. Поддержка пользовательских контекстных менеджеров. -->
<!-- 6. Улучшение читаемости и безопасности кода. -->
---
## 35 yield
<!-- 1. Создание генераторов. -->
<!-- 2. Возврат значения из функции-генератора с сохранением состояния. -->
<!-- 3. Постепенное вычисление значений (ленивые вычисления). -->
4. Использование в асинхронных функциях (в сочетании с `async`).
5. Поддержка итерации по элементам без загрузки всех данных в память.
---
## 36 async
1. Объявление асинхронных функций.
2. Поддержка асинхронного выполнения кода.
<!-- 3. Использование в сочетании с `await` для управления асинхронными операциями. -->
<!-- 4. Интеграция с asyncio для работы с событиями и корутинами. -->
<!-- 5. Создание конкурентных программ. -->
---
## 37 await
<!-- 1. Приостановка выполнения асинхронной функции до завершения awaitable-объекта. -->
2. Использование внутри асинхронных функций (`async def`).
<!-- 3. Ожидание результата асинхронных операций (например, I/O). -->
<!-- 4. Работа с корутинами, задачами и futures. -->
<!-- 5. Управление потоком выполнения в асинхронном коде. -->
---
## 38 assert
<!-- 1. Проверка условий в режиме отладки. -->
<!-- 2. Генерация исключения `AssertionError`, если условие ложно. -->
<!-- 3. Использование для проверки инвариантов и корректности данных. -->
<!-- 4. Отключение проверок при запуске с оптимизацией (`-O`). -->
<!-- 5. Указание дополнительного сообщения об ошибке. -->
---
## 39 del
<!-- 1. Удаление объектов (переменных, элементов коллекций, атрибутов). -->
<!-- 2. Освобождение памяти путём удаления ссылок на объекты. -->
<!-- 3. Удаление элементов из списков, словарей и других коллекций по индексу или ключу. -->
<!-- 4. Использование для управления областью видимости. -->
<!-- 5. Невозможность удаления неизменяемых объектов (например, кортежей). -->
---